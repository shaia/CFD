name: Build and Test

# Reusable workflow for building and testing binaries (no release creation)
# Also runs directly on push to master/main
on:
  push:
    branches: [master, main]
  workflow_call:
    inputs:
      version:
        description: 'Version label for artifacts'
        required: false
        type: string
        default: 'dev'
      retention_days:
        description: 'Artifact retention days'
        required: false
        type: number
        default: 7

env:
  BUILD_TYPE: Release
  CTEST_OUTPUT_ON_FAILURE: 1

jobs:
  build-matrix:
    name: Build ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          # Windows builds
          - {
              name: "Windows MSVC x64",
              os: windows-latest,
              generator: "Visual Studio 17 2022",
              arch: "x64",
              build_type: "Release",
              cc: "cl",
              cxx: "cl",
              artifact_name: "cfd-windows-x64"
            }
          - {
              name: "Windows MSVC x86",
              os: windows-latest,
              generator: "Visual Studio 17 2022",
              arch: "Win32",
              build_type: "Release",
              cc: "cl",
              cxx: "cl",
              artifact_name: "cfd-windows-x86"
            }

          # Linux builds
          - {
              name: "Linux GCC x64",
              os: ubuntu-latest,
              generator: "Unix Makefiles",
              build_type: "Release",
              cc: "gcc",
              cxx: "g++",
              artifact_name: "cfd-linux-x64"
            }
          - {
              name: "Linux Clang x64",
              os: ubuntu-latest,
              generator: "Unix Makefiles",
              build_type: "Release",
              cc: "clang",
              cxx: "clang++",
              artifact_name: "cfd-linux-clang-x64"
            }

          # macOS builds (macos-13 retired, using macos-14 for ARM64)
          - {
              name: "macOS ARM64",
              os: macos-14,  # Apple Silicon (M1)
              generator: "Unix Makefiles",
              build_type: "Release",
              cc: "clang",
              cxx: "clang++",
              artifact_name: "cfd-macos-arm64"
            }

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache CMake build
        uses: actions/cache@v4
        with:
          path: build
          key: ${{ runner.os }}-${{ matrix.config.artifact_name }}-build-${{ hashFiles('**/CMakeLists.txt') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.config.artifact_name }}-build-

      # Linux setup
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build

      # macOS setup
      - name: Install macOS dependencies
        if: runner.os == 'macOS'
        run: |
          brew install cmake ninja

      # Windows setup
      - name: Setup MSVC
        if: runner.os == 'Windows'
        uses: microsoft/setup-msbuild@v1.3

      - name: Configure CMake
        run: |
          mkdir -p build
          cd build

          # Set compiler environment variables
          if [ "$RUNNER_OS" == "Linux" ] || [ "$RUNNER_OS" == "macOS" ]; then
            export CC=${{ matrix.config.cc }}
            export CXX=${{ matrix.config.cxx }}
          fi

          # Configure based on platform
          if [ "$RUNNER_OS" == "Windows" ]; then
            cmake .. -G "${{ matrix.config.generator }}" -A ${{ matrix.config.arch }} \
              -DCMAKE_BUILD_TYPE=${{ matrix.config.build_type }} \
              -DBUILD_SHARED_LIBS=ON \
              -DBUILD_EXAMPLES=ON \
              -DBUILD_TESTS=ON
          else
            cmake .. -G "${{ matrix.config.generator }}" \
              -DCMAKE_BUILD_TYPE=${{ matrix.config.build_type }} \
              -DBUILD_SHARED_LIBS=ON \
              -DBUILD_EXAMPLES=ON \
              -DBUILD_TESTS=ON \
              -DCMAKE_C_COMPILER=${{ matrix.config.cc }} \
              -DCMAKE_CXX_COMPILER=${{ matrix.config.cxx }}
          fi
        shell: bash

      - name: Build
        run: |
          cd build
          if [ "$RUNNER_OS" == "Windows" ]; then
            cmake --build . --config ${{ matrix.config.build_type }} --parallel
          else
            cmake --build . --parallel $(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)
          fi
        shell: bash

      - name: Test
        run: |
          cd build
          if [ "$RUNNER_OS" == "Windows" ]; then
            ctest -C ${{ matrix.config.build_type }} --output-on-failure
          else
            ctest --output-on-failure
          fi
        shell: bash

      - name: Package binaries
        run: |
          # Create distribution directory
          mkdir -p dist/${{ matrix.config.artifact_name }}
          cd dist/${{ matrix.config.artifact_name }}

          # Copy binaries based on platform
          if [ "$RUNNER_OS" == "Windows" ]; then
            # Windows: Copy only library files (.lib, .dll)
            find ../../build -name "*.lib" -exec cp {} . \;
            find ../../build -name "*.dll" -exec cp {} . \;
            find ../../build -name "*.pdb" -exec cp {} . \; 2>/dev/null || true

            # Copy headers
            mkdir -p include
            cp -r ../../lib/include/* include/

            # Create info file
            echo "CFD Library - Windows ${{ matrix.config.arch }} Release" > README.txt
            echo "Built on: $(date)" >> README.txt
            echo "Compiler: MSVC" >> README.txt
            echo "Version: ${{ inputs.version || 'dev' }}" >> README.txt
            echo "" >> README.txt
            echo "Files included:" >> README.txt
            echo "- cfd_library.lib (static library)" >> README.txt
            echo "- cfd_library.dll (dynamic library)" >> README.txt
            echo "- include/ (header files)" >> README.txt

          else
            # Linux/macOS: Copy library files only (.so/.dylib, .a)
            if [ "$RUNNER_OS" == "Linux" ]; then
              find ../../build -name "*.so*" -exec cp {} . \;
              LIB_EXT="so"
            else
              find ../../build -name "*.dylib*" -exec cp {} . \;
              LIB_EXT="dylib"
            fi

            # Copy static libraries
            find ../../build -name "*.a" -exec cp {} . \;

            # Copy headers
            mkdir -p include
            cp -r ../../lib/include/* include/

            # Create info file
            echo "CFD Library - ${{ matrix.config.name }} Release" > README.txt
            echo "Built on: $(date)" >> README.txt
            echo "Compiler: ${{ matrix.config.cc }}" >> README.txt
            echo "Version: ${{ inputs.version || 'dev' }}" >> README.txt
            echo "" >> README.txt
            echo "Files included:" >> README.txt
            echo "- libcfd_library.a (static library)" >> README.txt
            if [ "$RUNNER_OS" == "Linux" ]; then
              echo "- libcfd_library.so (shared library)" >> README.txt
            else
              echo "- libcfd_library.dylib (shared library)" >> README.txt
            fi
            echo "- include/ (header files)" >> README.txt
          fi

          # List contents
          echo "" >> README.txt
          echo "Directory contents:" >> README.txt
          ls -la >> README.txt
        shell: bash

      - name: Create archive
        run: |
          cd dist
          if [ "$RUNNER_OS" == "Windows" ]; then
            # Create ZIP for Windows
            powershell -Command "Compress-Archive -Path '${{ matrix.config.artifact_name }}/*' -DestinationPath '${{ matrix.config.artifact_name }}.zip'"
          else
            # Create tar.gz for Unix systems
            tar -czf ${{ matrix.config.artifact_name }}.tar.gz ${{ matrix.config.artifact_name }}/
          fi
        shell: bash

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.config.artifact_name }}
          path: |
            dist/${{ matrix.config.artifact_name }}.*
          retention-days: ${{ inputs.retention_days }}

      - name: Generate build summary
        run: |
          echo "## Build Summary: ${{ matrix.config.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ runner.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: ${{ matrix.config.cc }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Architecture**: ${{ matrix.config.arch || 'x64' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: ${{ matrix.config.build_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ inputs.version || 'dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show binary info
          cd dist/${{ matrix.config.artifact_name }}
          echo "### Generated Files:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          ls -la >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # SIMD (AVX2) build - Test SIMD optimizations (AVX2 REQUIRED)
  simd-test-linux:
    name: SIMD AVX2 (Linux GCC)
    runs-on: ubuntu-latest

    steps:
      - name: Verify AVX2 hardware support (REQUIRED)
        run: |
          echo "CPU Info:"
          lscpu | grep -E "(Model name|Flags)" || cat /proc/cpuinfo | grep -E "(model name|flags)" | head -2
          echo ""
          if grep -q avx2 /proc/cpuinfo; then
            echo "✅ AVX2 is supported on this runner"
          else
            echo "❌ ERROR: AVX2 is NOT supported on this runner"
            echo "This job REQUIRES AVX2 hardware. GitHub runners should have AVX2."
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      - name: Configure with AVX2
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON \
            -DCFD_ENABLE_AVX2=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Verify AVX2 code is running
        run: |
          cd build
          # Run the linear solver test and check that SIMD is reported as available
          OUTPUT=$(./test_linear_solver 2>&1 || true)
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "SIMD backend available: YES"; then
            echo "✅ AVX2 SIMD backend is correctly enabled"
          else
            echo "❌ ERROR: AVX2 was expected but SIMD backend reports NO"
            echo "This means the code was not compiled with AVX2 support"
            exit 1
          fi
          # Verify we see the AVX2 description
          if echo "$OUTPUT" | grep -q "AVX2 SIMD"; then
            echo "✅ AVX2 SIMD solver descriptions found"
          else
            echo "❌ ERROR: AVX2 SIMD solver not found in output"
            exit 1
          fi

      - name: Generate summary
        if: always()
        run: |
          echo "## SIMD AVX2 (Linux GCC) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AVX2 Required**: Yes (mandatory for this job)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: GCC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # SIMD (AVX2) build - Windows (AVX2 REQUIRED)
  simd-test-windows:
    name: SIMD AVX2 (Windows MSVC)
    runs-on: windows-latest

    steps:
      - name: Verify AVX2 hardware support (REQUIRED)
        shell: powershell
        run: |
          $cpu = Get-CimInstance Win32_Processor
          Write-Host "CPU: $($cpu.Name)"
          Write-Host ""
          # Windows GitHub runners (Azure VMs) use Intel Xeon which has AVX2
          # If this ever fails, the runner changed and we need to investigate
          Write-Host "✅ AVX2 is required on this runner (Intel Xeon expected)"
          Write-Host "This job REQUIRES AVX2 hardware. GitHub runners should have AVX2."

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup MSVC
        uses: microsoft/setup-msbuild@v1.3

      - name: Configure with AVX2
        shell: bash
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Visual Studio 17 2022" -A x64 \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON \
            -DCFD_ENABLE_AVX2=ON

      - name: Build
        shell: bash
        run: |
          cd build
          cmake --build . --config Release --parallel

      - name: Run tests
        shell: bash
        run: |
          cd build
          ctest -C Release --output-on-failure

      - name: Verify AVX2 code is running
        shell: bash
        run: |
          cd build
          # Run the linear solver test and check that SIMD is reported as available
          OUTPUT=$(./Release/test_linear_solver.exe 2>&1 || true)
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "SIMD backend available: YES"; then
            echo "✅ AVX2 SIMD backend is correctly enabled"
          else
            echo "❌ ERROR: AVX2 was expected but SIMD backend reports NO"
            echo "This means the code was not compiled with AVX2 support"
            exit 1
          fi
          # Verify we see the AVX2 description
          if echo "$OUTPUT" | grep -q "AVX2 SIMD"; then
            echo "✅ AVX2 SIMD solver descriptions found"
          else
            echo "❌ ERROR: AVX2 SIMD solver not found in output"
            exit 1
          fi

      - name: Generate summary
        if: always()
        shell: bash
        run: |
          echo "## SIMD AVX2 (Windows MSVC) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AVX2 Required**: Yes (mandatory for this job)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: MSVC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # Sanitizer build - Debug build with ASan and UBSan
  sanitizers:
    name: Sanitizers (Linux GCC)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build

      - name: Configure with sanitizers
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=ON \
            -DBUILD_TESTS=ON \
            -DENABLE_ASAN=ON \
            -DENABLE_UBSAN=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run tests with sanitizers
        env:
          ASAN_OPTIONS: detect_leaks=1:abort_on_error=1
          UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate summary
        if: always()
        run: |
          echo "## Sanitizer Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AddressSanitizer**: Enabled" >> $GITHUB_STEP_SUMMARY
          echo "- **UndefinedBehaviorSanitizer**: Enabled" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: GCC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Debug" >> $GITHUB_STEP_SUMMARY

  # Code coverage build
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake lcov

      - name: Configure with coverage
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON \
            -DENABLE_COVERAGE=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate coverage report
        run: |
          cd build
          # Capture coverage data
          lcov --capture --directory . --output-file coverage.info --ignore-errors mismatch
          # Remove external dependencies from coverage
          lcov --remove coverage.info '/usr/*' '*/Unity/*' '*/_deps/*' '*/tests/*' --output-file coverage.info --ignore-errors unused
          # Generate HTML report
          genhtml coverage.info --output-directory coverage-report

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: build/coverage-report/
          retention-days: ${{ inputs.retention_days }}

      - name: Generate summary
        run: |
          echo "## Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Coverage report generated. Download the artifact for detailed HTML report." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cd build
          lcov --summary coverage.info 2>&1 | tee -a $GITHUB_STEP_SUMMARY

  # API Documentation build (only on main/master branch or releases)
  docs:
    name: API Documentation
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'release'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Doxygen
        run: |
          sudo apt-get update
          sudo apt-get install -y doxygen

      - name: Generate documentation
        run: doxygen Doxyfile

      - name: Verify documentation output
        run: |
          if [ ! -d "docs/html" ]; then
            echo "Error: docs/html/ directory not created"
            exit 1
          fi
          if [ ! -f "docs/html/index.html" ]; then
            echo "Error: docs/html/index.html not found"
            exit 1
          fi
          echo "Documentation generated successfully"
          ls -la docs/html/ | head -20

      - name: Upload documentation
        uses: actions/upload-artifact@v4
        with:
          name: api-docs
          path: docs/html/
          retention-days: ${{ inputs.retention_days }}

      - name: Generate summary
        run: |
          echo "## API Documentation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Doxygen documentation generated successfully." >> $GITHUB_STEP_SUMMARY
          echo "Download the 'api-docs' artifact to view." >> $GITHUB_STEP_SUMMARY

  # Status check job - Required for PR merges
  build-status:
    name: Build Status Check
    runs-on: ubuntu-latest
    needs: [build-matrix, simd-test-linux, simd-test-windows, sanitizers, coverage, docs]
    if: always()

    steps:
      - name: Check build results
        run: |
          # docs job may be skipped on feature branches, so treat 'skipped' as success
          DOCS_OK="${{ needs.docs.result == 'success' || needs.docs.result == 'skipped' }}"
          SIMD_LINUX_OK="${{ needs.simd-test-linux.result == 'success' }}"
          SIMD_WINDOWS_OK="${{ needs.simd-test-windows.result == 'success' }}"
          if [[ "${{ needs.build-matrix.result }}" == "success" && "$SIMD_LINUX_OK" == "true" && "$SIMD_WINDOWS_OK" == "true" && "${{ needs.sanitizers.result }}" == "success" && "${{ needs.coverage.result }}" == "success" && "$DOCS_OK" == "true" ]]; then
            echo "✅ All builds passed successfully!"
            echo "Build Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "All platforms built and tested successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ One or more builds failed!"
            echo "Build Status: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Check individual build jobs for details." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
