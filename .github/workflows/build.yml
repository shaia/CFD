name: Build and Test

# Reusable workflow for building and testing binaries (no release creation)
# Also runs directly on push to master/main
on:
  push:
    branches: [master, main]
  workflow_call:
    inputs:
      version:
        description: 'Version label for artifacts'
        required: false
        type: string
        default: 'dev'
      retention_days:
        description: 'Artifact retention days'
        required: false
        type: number
        default: 7

env:
  BUILD_TYPE: Release
  CTEST_OUTPUT_ON_FAILURE: 1

jobs:
  build-matrix:
    name: Build ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          # Windows builds
          - {
              name: "Windows MSVC x64",
              os: windows-latest,
              generator: "Visual Studio 17 2022",
              arch: "x64",
              build_type: "Release",
              cc: "cl",
              cxx: "cl",
              artifact_name: "cfd-windows-x64"
            }
          - {
              name: "Windows MSVC x86",
              os: windows-latest,
              generator: "Visual Studio 17 2022",
              arch: "Win32",
              build_type: "Release",
              cc: "cl",
              cxx: "cl",
              artifact_name: "cfd-windows-x86"
            }

          # Linux builds
          - {
              name: "Linux GCC x64",
              os: ubuntu-latest,
              generator: "Unix Makefiles",
              build_type: "Release",
              cc: "gcc",
              cxx: "g++",
              artifact_name: "cfd-linux-x64"
            }
          - {
              name: "Linux Clang x64",
              os: ubuntu-latest,
              generator: "Unix Makefiles",
              build_type: "Release",
              cc: "clang",
              cxx: "clang++",
              artifact_name: "cfd-linux-clang-x64"
            }

          # macOS builds (macos-13 retired, using macos-14 for ARM64)
          - {
              name: "macOS ARM64",
              os: macos-14,  # Apple Silicon (M1)
              generator: "Unix Makefiles",
              build_type: "Release",
              cc: "clang",
              cxx: "clang++",
              artifact_name: "cfd-macos-arm64"
            }

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache CMake build
        uses: actions/cache@v4
        with:
          path: build
          key: ${{ runner.os }}-${{ matrix.config.artifact_name }}-build-${{ hashFiles('**/CMakeLists.txt') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.config.artifact_name }}-build-

      # Linux setup
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build

      # macOS setup
      - name: Install macOS dependencies
        if: runner.os == 'macOS'
        run: |
          brew install cmake ninja

      # Windows setup
      - name: Setup MSVC
        if: runner.os == 'Windows'
        uses: microsoft/setup-msbuild@v1.3

      - name: Configure CMake
        run: |
          mkdir -p build
          cd build

          # Set compiler environment variables
          if [ "$RUNNER_OS" == "Linux" ] || [ "$RUNNER_OS" == "macOS" ]; then
            export CC=${{ matrix.config.cc }}
            export CXX=${{ matrix.config.cxx }}
          fi

          # Configure based on platform
          if [ "$RUNNER_OS" == "Windows" ]; then
            cmake .. -G "${{ matrix.config.generator }}" -A ${{ matrix.config.arch }} \
              -DCMAKE_BUILD_TYPE=${{ matrix.config.build_type }} \
              -DBUILD_SHARED_LIBS=ON \
              -DBUILD_EXAMPLES=ON \
              -DBUILD_TESTS=ON
          else
            cmake .. -G "${{ matrix.config.generator }}" \
              -DCMAKE_BUILD_TYPE=${{ matrix.config.build_type }} \
              -DBUILD_SHARED_LIBS=ON \
              -DBUILD_EXAMPLES=ON \
              -DBUILD_TESTS=ON \
              -DCMAKE_C_COMPILER=${{ matrix.config.cc }} \
              -DCMAKE_CXX_COMPILER=${{ matrix.config.cxx }}
          fi
        shell: bash

      - name: Build
        run: |
          cd build
          if [ "$RUNNER_OS" == "Windows" ]; then
            cmake --build . --config ${{ matrix.config.build_type }} --parallel
          else
            cmake --build . --parallel $(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)
          fi
        shell: bash

      - name: Test
        run: |
          cd build
          if [ "$RUNNER_OS" == "Windows" ]; then
            ctest -C ${{ matrix.config.build_type }} --output-on-failure
          else
            ctest --output-on-failure
          fi
        shell: bash

      - name: Package binaries
        run: |
          # Create distribution directory
          mkdir -p dist/${{ matrix.config.artifact_name }}
          cd dist/${{ matrix.config.artifact_name }}

          # Copy binaries based on platform
          if [ "$RUNNER_OS" == "Windows" ]; then
            # Windows: Copy only library files (.lib, .dll)
            find ../../build -name "*.lib" -exec cp {} . \;
            find ../../build -name "*.dll" -exec cp {} . \;
            find ../../build -name "*.pdb" -exec cp {} . \; 2>/dev/null || true

            # Copy headers
            mkdir -p include
            cp -r ../../lib/include/* include/

            # Create info file
            echo "CFD Library - Windows ${{ matrix.config.arch }} Release" > README.txt
            echo "Built on: $(date)" >> README.txt
            echo "Compiler: MSVC" >> README.txt
            echo "Version: ${{ inputs.version || 'dev' }}" >> README.txt
            echo "" >> README.txt
            echo "Files included:" >> README.txt
            echo "- cfd_library.lib (static library)" >> README.txt
            echo "- cfd_library.dll (dynamic library)" >> README.txt
            echo "- include/ (header files)" >> README.txt

          else
            # Linux/macOS: Copy library files only (.so/.dylib, .a)
            if [ "$RUNNER_OS" == "Linux" ]; then
              find ../../build -name "*.so*" -exec cp {} . \;
              LIB_EXT="so"
            else
              find ../../build -name "*.dylib*" -exec cp {} . \;
              LIB_EXT="dylib"
            fi

            # Copy static libraries
            find ../../build -name "*.a" -exec cp {} . \;

            # Copy headers
            mkdir -p include
            cp -r ../../lib/include/* include/

            # Create info file
            echo "CFD Library - ${{ matrix.config.name }} Release" > README.txt
            echo "Built on: $(date)" >> README.txt
            echo "Compiler: ${{ matrix.config.cc }}" >> README.txt
            echo "Version: ${{ inputs.version || 'dev' }}" >> README.txt
            echo "" >> README.txt
            echo "Files included:" >> README.txt
            echo "- libcfd_library.a (static library)" >> README.txt
            if [ "$RUNNER_OS" == "Linux" ]; then
              echo "- libcfd_library.so (shared library)" >> README.txt
            else
              echo "- libcfd_library.dylib (shared library)" >> README.txt
            fi
            echo "- include/ (header files)" >> README.txt
          fi

          # List contents
          echo "" >> README.txt
          echo "Directory contents:" >> README.txt
          ls -la >> README.txt
        shell: bash

      - name: Create archive
        run: |
          cd dist
          if [ "$RUNNER_OS" == "Windows" ]; then
            # Create ZIP for Windows
            powershell -Command "Compress-Archive -Path '${{ matrix.config.artifact_name }}/*' -DestinationPath '${{ matrix.config.artifact_name }}.zip'"
          else
            # Create tar.gz for Unix systems
            tar -czf ${{ matrix.config.artifact_name }}.tar.gz ${{ matrix.config.artifact_name }}/
          fi
        shell: bash

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.config.artifact_name }}
          path: |
            dist/${{ matrix.config.artifact_name }}.*
          retention-days: ${{ inputs.retention_days }}

      - name: Generate build summary
        run: |
          echo "## Build Summary: ${{ matrix.config.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ runner.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: ${{ matrix.config.cc }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Architecture**: ${{ matrix.config.arch || 'x64' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: ${{ matrix.config.build_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ inputs.version || 'dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show binary info
          cd dist/${{ matrix.config.artifact_name }}
          echo "### Generated Files:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          ls -la >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # SIMD (AVX2) build - Test SIMD optimizations (AVX2 REQUIRED)
  simd-test-linux:
    name: SIMD AVX2 (Linux GCC)
    runs-on: ubuntu-latest

    steps:
      - name: Verify AVX2 hardware support (REQUIRED)
        run: |
          echo "CPU Info:"
          lscpu | grep -E "(Model name|Flags)" || cat /proc/cpuinfo | grep -E "(model name|flags)" | head -2
          echo ""
          if grep -q avx2 /proc/cpuinfo; then
            echo "✅ AVX2 is supported on this runner"
          else
            echo "❌ ERROR: AVX2 is NOT supported on this runner"
            echo "This job REQUIRES AVX2 hardware. GitHub runners should have AVX2."
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      - name: Configure with AVX2
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON \
            -DCFD_ENABLE_AVX2=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Verify AVX2 code is running
        run: |
          cd build
          # Run the linear solver test and check that SIMD is reported as available
          OUTPUT=$(./test_linear_solver 2>&1 || true)
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "SIMD backend available: YES"; then
            echo "✅ AVX2 SIMD backend is correctly enabled"
          else
            echo "❌ ERROR: AVX2 was expected but SIMD backend reports NO"
            echo "This means the code was not compiled with AVX2 support"
            exit 1
          fi
          # Verify we see the AVX2 description
          if echo "$OUTPUT" | grep -q "AVX2 SIMD"; then
            echo "✅ AVX2 SIMD solver descriptions found"
          else
            echo "❌ ERROR: AVX2 SIMD solver not found in output"
            exit 1
          fi

      - name: Generate summary
        if: always()
        run: |
          echo "## SIMD AVX2 (Linux GCC) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AVX2 Required**: Yes (mandatory for this job)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: GCC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # SIMD (AVX2) build - Windows (AVX2 REQUIRED)
  simd-test-windows:
    name: SIMD AVX2 (Windows MSVC)
    runs-on: windows-latest

    steps:
      - name: Verify AVX2 hardware support (REQUIRED)
        shell: powershell
        run: |
          $cpu = Get-CimInstance Win32_Processor
          Write-Host "CPU: $($cpu.Name)"
          Write-Host ""
          # Windows GitHub runners (Azure VMs) use Intel Xeon which has AVX2
          # If this ever fails, the runner changed and we need to investigate
          Write-Host "✅ AVX2 is required on this runner (Intel Xeon expected)"
          Write-Host "This job REQUIRES AVX2 hardware. GitHub runners should have AVX2."

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup MSVC
        uses: microsoft/setup-msbuild@v1.3

      - name: Configure with AVX2
        shell: bash
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Visual Studio 17 2022" -A x64 \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON \
            -DCFD_ENABLE_AVX2=ON

      - name: Build
        shell: bash
        run: |
          cd build
          cmake --build . --config Release --parallel

      - name: Run tests
        shell: bash
        run: |
          cd build
          ctest -C Release --output-on-failure

      - name: Verify AVX2 code is running
        shell: bash
        run: |
          cd build
          # Run the linear solver test and check that SIMD is reported as available
          OUTPUT=$(./Release/test_linear_solver.exe 2>&1 || true)
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "SIMD backend available: YES"; then
            echo "✅ AVX2 SIMD backend is correctly enabled"
          else
            echo "❌ ERROR: AVX2 was expected but SIMD backend reports NO"
            echo "This means the code was not compiled with AVX2 support"
            exit 1
          fi
          # Verify we see the AVX2 description
          if echo "$OUTPUT" | grep -q "AVX2 SIMD"; then
            echo "✅ AVX2 SIMD solver descriptions found"
          else
            echo "❌ ERROR: AVX2 SIMD solver not found in output"
            exit 1
          fi

      - name: Generate summary
        if: always()
        shell: bash
        run: |
          echo "## SIMD AVX2 (Windows MSVC) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AVX2 Required**: Yes (mandatory for this job)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: MSVC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # OpenMP build - Test OpenMP parallelization
  openmp-test-linux:
    name: OpenMP (Linux GCC)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      - name: Configure with OpenMP
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Verify OpenMP is enabled
        run: |
          cd build
          # Check CMake output shows OpenMP found
          if grep -q "OpenMP found" CMakeCache.txt 2>/dev/null || grep -q "CFD_ENABLE_OPENMP" CMakeCache.txt; then
            echo "✅ OpenMP support detected in build"
          fi
          # Run the linear solver test and check that OMP backend is available
          OUTPUT=$(./test_linear_solver 2>&1 || true)
          echo "$OUTPUT"

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate summary
        if: always()
        run: |
          echo "## OpenMP (Linux GCC) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OpenMP**: Enabled (GCC has built-in OpenMP support)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: GCC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # OpenMP build - Test OpenMP with Clang (requires libomp)
  openmp-test-clang:
    name: OpenMP (Linux Clang)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake clang libomp-dev

      - name: Configure with OpenMP
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=clang \
            -DCMAKE_CXX_COMPILER=clang++ \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Verify OpenMP is enabled
        run: |
          cd build
          # Run test to verify OMP backend is available
          OUTPUT=$(./test_linear_solver 2>&1 || true)
          echo "$OUTPUT"

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate summary
        if: always()
        run: |
          echo "## OpenMP (Linux Clang) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OpenMP**: Enabled (via libomp)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: Clang" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # OpenMP build - Test OpenMP on Windows MSVC
  openmp-test-windows:
    name: OpenMP (Windows MSVC)
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup MSVC
        uses: microsoft/setup-msbuild@v1.3

      - name: Configure with OpenMP
        shell: bash
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Visual Studio 17 2022" -A x64 \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON

      - name: Build
        shell: bash
        run: |
          cd build
          cmake --build . --config Release --parallel

      - name: Verify OpenMP is enabled
        shell: bash
        run: |
          cd build
          # Check CMake output shows OpenMP found
          if grep -q "OpenMP found" CMakeCache.txt 2>/dev/null || grep -q "CFD_ENABLE_OPENMP" CMakeCache.txt; then
            echo "✅ OpenMP support detected in build"
          fi
          # Run the linear solver test and check that OMP backend is available
          OUTPUT=$(./Release/test_linear_solver.exe 2>&1 || true)
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "OMP backend available: YES"; then
            echo "✅ OpenMP backend is correctly enabled"
          else
            echo "❌ ERROR: OpenMP was expected but OMP backend reports NO"
            exit 1
          fi

      - name: Run tests
        shell: bash
        run: |
          cd build
          ctest -C Release --output-on-failure

      - name: Generate summary
        if: always()
        shell: bash
        run: |
          echo "## OpenMP (Windows MSVC) Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OpenMP**: Enabled (MSVC built-in)" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: MSVC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Release" >> $GITHUB_STEP_SUMMARY

  # CUDA build on Windows - Verify CUDA code compiles
  cuda-build-windows:
    name: CUDA Build (Windows)
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup MSVC
        uses: microsoft/setup-msbuild@v1.3

      - name: Install CUDA Toolkit
        uses: Jimver/cuda-toolkit@v0.2.16
        id: cuda-toolkit
        with:
          cuda: '12.4.0'
          method: 'network'

      - name: Configure CMake with CUDA
        shell: pwsh
        run: |
          mkdir build
          cd build
          cmake .. -G "Visual Studio 17 2022" -A x64 `
            -DCMAKE_BUILD_TYPE=Release `
            -DCFD_ENABLE_CUDA=ON `
            -DBUILD_TESTS=ON `
            -DBUILD_EXAMPLES=OFF

      - name: Build
        shell: pwsh
        run: |
          cd build
          cmake --build . --config Release --parallel

      - name: Verify CUDA compilation
        shell: pwsh
        run: |
          cd build
          Write-Host "Build completed successfully with CUDA support"
          Get-ChildItem -Recurse -Filter "*.lib" | Select-Object FullName

      - name: Generate summary
        if: always()
        shell: pwsh
        run: |
          echo "## CUDA Build (Windows) Summary" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "- **CUDA Version:** ${{ steps.cuda-toolkit.outputs.cuda }}" >> $env:GITHUB_STEP_SUMMARY
          echo "- **Compiler:** MSVC" >> $env:GITHUB_STEP_SUMMARY
          echo "- **Purpose:** Verify CUDA code compiles correctly" >> $env:GITHUB_STEP_SUMMARY

  # Sanitizer build - Debug build with ASan and UBSan
  sanitizers:
    name: Sanitizers (Linux GCC)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build

      - name: Configure with sanitizers
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=ON \
            -DBUILD_TESTS=ON \
            -DENABLE_ASAN=ON \
            -DENABLE_UBSAN=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run tests with sanitizers
        env:
          ASAN_OPTIONS: detect_leaks=1:abort_on_error=1
          UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate summary
        if: always()
        run: |
          echo "## Sanitizer Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AddressSanitizer**: Enabled" >> $GITHUB_STEP_SUMMARY
          echo "- **UndefinedBehaviorSanitizer**: Enabled" >> $GITHUB_STEP_SUMMARY
          echo "- **Compiler**: GCC" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: Debug" >> $GITHUB_STEP_SUMMARY

  # Code coverage build
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake lcov

      - name: Configure with coverage
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_C_COMPILER=gcc \
            -DBUILD_EXAMPLES=OFF \
            -DBUILD_TESTS=ON \
            -DENABLE_COVERAGE=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure

      - name: Generate coverage report
        run: |
          cd build
          # Capture coverage data
          lcov --capture --directory . --output-file coverage.info --ignore-errors mismatch
          # Remove external dependencies from coverage
          lcov --remove coverage.info '/usr/*' '*/Unity/*' '*/_deps/*' '*/tests/*' --output-file coverage.info --ignore-errors unused
          # Generate HTML report
          genhtml coverage.info --output-directory coverage-report

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: build/coverage-report/
          retention-days: ${{ inputs.retention_days }}

      - name: Generate summary
        run: |
          echo "## Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Coverage report generated. Download the artifact for detailed HTML report." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cd build
          lcov --summary coverage.info 2>&1 | tee -a $GITHUB_STEP_SUMMARY

  # CUDA build - Verify CUDA code compiles (no GPU hardware on CI runners)
  cuda-build:
    name: CUDA Build (Linux)
    runs-on: ubuntu-latest
    container:
      image: nvidia/cuda:12.2.0-devel-ubuntu22.04

    steps:
      - name: Install dependencies
        run: |
          apt-get update
          apt-get install -y build-essential cmake git

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure CMake with CUDA
        run: |
          mkdir -p build
          cd build
          cmake .. -G "Unix Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCFD_ENABLE_CUDA=ON \
            -DBUILD_TESTS=ON \
            -DBUILD_EXAMPLES=OFF

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Verify CUDA compilation
        run: |
          cd build
          echo "Checking for GPU symbols in library..."
          if nm -C lib/libcfd_library.a 2>/dev/null | grep -q "gpu"; then
            echo "✅ GPU symbols found in library"
            nm -C lib/libcfd_library.a | grep -i gpu | head -10
          else
            echo "❌ GPU symbols NOT found"
            nm -C lib/libcfd_library.a | head -30
            exit 1
          fi

      - name: Generate summary
        if: always()
        run: |
          echo "## CUDA Build (Linux) Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **CUDA Version:** 12.2" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type:** Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Purpose:** Verify CUDA code compiles correctly" >> $GITHUB_STEP_SUMMARY

  # Status check job - Required for PR merges
  build-status:
    name: Build Status Check
    runs-on: ubuntu-latest
    needs: [build-matrix, simd-test-linux, simd-test-windows, openmp-test-linux, openmp-test-clang, openmp-test-windows, cuda-build, cuda-build-windows, sanitizers, coverage]
    if: always()

    steps:
      - name: Check build results
        run: |
          SIMD_LINUX_OK="${{ needs.simd-test-linux.result == 'success' }}"
          SIMD_WINDOWS_OK="${{ needs.simd-test-windows.result == 'success' }}"
          OMP_GCC_OK="${{ needs.openmp-test-linux.result == 'success' }}"
          OMP_CLANG_OK="${{ needs.openmp-test-clang.result == 'success' }}"
          OMP_WINDOWS_OK="${{ needs.openmp-test-windows.result == 'success' }}"
          CUDA_OK="${{ needs.cuda-build.result == 'success' }}"
          CUDA_WIN_OK="${{ needs.cuda-build-windows.result == 'success' }}"
          if [[ "${{ needs.build-matrix.result }}" == "success" && "$SIMD_LINUX_OK" == "true" && "$SIMD_WINDOWS_OK" == "true" && "$OMP_GCC_OK" == "true" && "$OMP_CLANG_OK" == "true" && "$OMP_WINDOWS_OK" == "true" && "$CUDA_OK" == "true" && "$CUDA_WIN_OK" == "true" && "${{ needs.sanitizers.result }}" == "success" && "${{ needs.coverage.result }}" == "success" ]]; then
            echo "✅ All builds passed successfully!"
            echo "Build Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "All platforms built and tested successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ One or more builds failed!"
            echo "Build Status: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Check individual build jobs for details." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
